* Settings
:properties:
:hidden: true
:end:
#+BEGIN_SRC coffee :results def
{Solomon} = window
if !window.Solomon
  @Solomon = {}
  {@Handlebars} = Leisure
  {define: @defineL, @Monad2} = Leisure.Runtime
  @rz = resolve
#+END_SRC
* Map
#+BEGIN_HTML :var mapData
<div class="map">
  {{#each mapData}}
    <div class='mapLayer{{#unless @first}} floatingLayer{{/unless}}'>
      {{#each this}}
        <div class="row {{#if_even @index}} even{{/if_even}}">
          {{#each this}}<div class="tile-sprite iso" data-code="{{this}}" data-coords="{{@index}} {{@../index}}"></div>{{/each}}
        </div>
      {{/each}}
    </div>
  {{/each}}
</div>
#+END_HTML
* Map def
#+NAME: mapData
#+BEGIN_SRC yaml :post mapFormatter(*this*) :results dynamic :flowlevel 2
- -
  -
  -
  -
  -
  -
  -
  - I0a0a0a0a0a0a0a0
  - I0a0a0a0a0a0a0
  - I0I0a0a0a0a0a0a0a0
  - I0a0a0a0a0a0a0a0
  - I0I0a0a0a0a0a0a0a0
  - I0a0a0a
  -
  -
- -
  -
  -
  -
  -
  - I0I0I0n0I0I0I0
  - I0I0l0l1
  - I0I0m0a0p0
  - I0m0
  - I0l0
  - n3
  - I0l3
  - I0l3
  -
  -
#+END_SRC
#+RESULTS:
: - - []
:   - []
:   - []
:   - []
:   - []
:   - []
:   - []
:   - [I0, a0, a0, a0, a0, a0, a0, a0]
:   - [I0, a0, a0, a0, a0, a0, a0]
:   - [I0, I0, a0, a0, a0, a0, a0, a0, a0]
:   - [I0, a0, a0, a0, a0, a0, a0, a0]
:   - [I0, I0, a0, a0, a0, a0, a0, a0, a0]
:   - [I0, a0, a0, a]
:   - []
:   - [I0]
: - - []
:   - []
:   - []
:   - []
:   - []
:   - [I0, I0, I0, n0, I0, I0, I0]
:   - [I0, I0, l0, l1]
:   - [I0, I0, m0, a0, p0]
:   - [I0, m0]
:   - [I0, l0]
:   - [n3]
:   - [I0, l3]
:   - [I0, l3]

#+NAME: mapFormatter
This takes mapData and formats is for easier rendering in the map view
#+BEGIN_SRC coffee :var mapData
_.map mapData, (level)-> _.map level, (v)-> _.map _.chunk(v, 2), (i)-> i.join ''
#+END_SRC
* Map Tile Styles
#+BEGIN_SRC leisure :results def
buildStyles data = strCat (do
  i <- forFlat data
  t = tail i
  codes = ((assoc 'codes' t) id '')
  offsetX = ((assoc 'offsetX' t) id 0)
  topPos = ((assoc 'offsetY' t) id 0)
  widthOfCurrent = ((assoc 'width' t) id 0)
  j <- forFlat range 0 (strLen codes)
  c = strAt codes j
  not c == '_'
  k <- forFlat range 0 4
  leftPos = offsetX + widthOfCurrent * k + (j % 4) * 4 * widthOfCurrent
  [s['.tile-sprite[data-code="' c k '"] {\n']
    s['  background-position: -' leftPos 'px -' topPos + (floor j / 4) * ((assoc 'height' t) id 0) 'px !important;\n']
    s['  height: ' ((assoc 'height' t) id 0) 'px;\n']
    s['  top: ' (32 - ((assoc 'height' t) id 0)) 'px;\n']
    s['  width: ' widthOfCurrent 'px;\n']
    s['}\n']])
#+END_SRC

#+BEGIN_SRC coffee
defineL 'setTileTypes', (types)-> new Monad2 'setTileTypes', (env, cont)->
  Solomon.tileTypes = resolve
#+END_SRC

#+BEGIN_SRC leisure :results defX
changeData
  bgndUrl <- run getImage 'tiles/backgroundFloorTile.png'
  updateStyles 'map-styles' s['.map {\n'
    s['  background: url(' bgndUrl ');\n']
    '}\n']
  updateTileTypes
#+END_SRC

#+BEGIN_SRC leisure :results def
changeData
  url <- run getImage 'tiles/tileset_cave_1.png'
  data <- run getData 'tileSets'
  updateStyles 'tile-styles' s['.tile-sprite {\n'
    s['  background-image: url(' url ');\n']
    '  background-repeat: no-repeat;\n'
    '  position: relative;\n'
    '  vertical-align: top;\n'
    '}\n'
    (buildStyles data)]
#+END_SRC

#+TITLE: Test Isometric Tiles
* tests
#+BEGIN_SRC leisure :results dynamic
map id (toList (range 0 4))
#+END_SRC
* Tiles
#+BEGIN_SRC coffee :results def
Handlebars.registerHelper 'stringChunk', (string, chunkSize)->
  el.join '' for el in _.chunk(string, chunkSize)
backwardsTiles = "l2l3m2m3"
Handlebars.registerHelper 'tiles', (string)->
  {name: el, } for el in _.chunk(string, 2)
Handlebars.registerHelper 'fixupTile', (string)->

#+END_SRC

#+NAME: tileSets
#+BEGIN_SRC yaml
floor:
  codes: abcdefghijk
  offsetX: 0
  offsetY: 0
  width: 64
  height: 32
walls:
  codes: lmnopq__rstuv
  offsetX: 0
  offsetY: 125
  width: 64
  height: 128
objects:
  codes: wx
  offsetX: 0
  offsetY: 640
  width: 64
  height: 64
rocks:
  codes: yzA
  offsetX: 0
  offsetY: 704
  width: 64
  height: 128
water:
  codes: BCDEFGH
  offsetX: 0
  offsetY: 832
  width: 64
  height: 64
black:
  codes: I
  offsetX: 768
  offsetY: 906
  width: 64
  height: 32
#+END_SRC

#+BEGIN_SRC coffee :results def
Handlebars.registerHelper 'if_even', (conditional, options)->
  if (conditional % 2) == 0 then options.fn(this) else options.inverse(this)
#+END_SRC

#+BEGIN_SRC css
.map {
  margin-top: 3em;
  width: 1024px;
  overflow: hidden;
  padding-bottom: 16px;
  white-space: nowrap;
  position: relative;
  background: black;
}
.floatingLayer {
  position: absolute;
  top: 0;
  left: 0;
}
.row {
  height: 16px;
}
.even {
  padding-left: 32px;
}
.iso {
  display: inline-block;
  width: 64px;
  height: 32px;
  position: relative;
}
.tile-sprite[data-code=zz] {
  background: black;
}
#+END_SRC
* Leisure code
** Primitives for Leisure
#+BEGIN_SRC coffee :results def
{right, left, isPartial, partialCall, Monad2} = Leisure.Runtime

defineL 'updateStyles', (id, str)->
  new Monad2 (env, cont)->
    $("##{rz id}").remove()
    $(document.head).append "<style id='#{rz id}'>#{resolve str}</style>"
#+END_SRC
